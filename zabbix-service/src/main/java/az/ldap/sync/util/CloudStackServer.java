package az.ldap.sync.util;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.util.EncodingUtil;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.util.UriComponents;
import org.springframework.web.util.UriComponentsBuilder;

import az.ldap.sync.constants.CloudStackConstants;

/**
 * Cloudstack server component to connect to cloudstack server.
 *
 * It requires cloudstack credentials to be set.
 *
 */
@Component
public class CloudStackServer {

	/** secret key for authentication. */
    private String secretKey;

    /** api key unique for an account.This should have been generated by the administrator of the cloud instance. */
    private String apiKey;

    /** URL that connects with cloudstack. */
    private String apiURL;
    
    /** The Ldap host and port. */
	@Value(value = "${ldap.url}")
	private String ldapUrl;
    
    /** Cloud stack optional value for domain name. */
    public static final String CS_DOMAIN = "domain";

    /** Logger attribute. */
    private static final Logger LOGGER = LoggerFactory.getLogger(CloudStackServer.class);

    /**
     * Set CloudStack API connector.
     *
     * @param apiURL URL of the CloudStack server
     * @param secretKey secret key to generate sign API request.
     * @param apikey which uniquely identifies the account.
     */
    public void setServer(String apiURL, String secretKey, String apiKey) {
        this.apiURL = apiURL;
        this.secretKey = secretKey;
        this.apiKey = apiKey;
        
    }   

    /**
     * URL Mapping.All CloudStack API requests are submitted in the form of a HTTP GET/POST with an associated command
     * and any parameters.
     *
     * @param queryValuePair - The web services command we wish to execute, such as create a virtual machine or create a
     *            disk volume
     * @return response object from CloudStack as a json object.
     * @throws Exception if any invalid parameters.
     */
    public String request(MultiValueMap<String, String> queryValuePair) throws Exception {
    	UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(apiURL);
    	queryValuePair.add("signature", generateSignature(queryValuePair));
    	LOGGER.debug("All query Value pair With Signature " + queryValuePair.toString());
    	builder.queryParams(queryValuePair);
		UriComponents uriComponents = builder.build();
		LOGGER.debug("Requested API URL " + uriComponents.encode().toString());
		String responseObject = RestClient.doGet(uriComponents.encode().toString(), queryValuePair);
		LOGGER.info("API RESPONSE" +  responseObject);
		return responseObject;
    }

    /**
     * URL Mapping.All CloudStack API requests are submitted in the form of a HTTP GET/POST with an associated command
     * and any parameters.
     *
     * @param queryValues - The web services command we wish to execute, such as create a virtual machine or create a
     *            disk volume
     * @return response object from CloudStack as a json object.
     * @throws Exception if any invalid parameters.
     */
    public String requestLogin(MultiValueMap<String, String> queryValues) throws Exception {
    	queryValues.remove("apiKey");
		String querySignature = generateSignatureForPost(queryValues);
		queryValues.add("signature", querySignature);
        String response = RestClient.doPost(apiURL, queryValues);
        return response;
    }

    /**
     * Common parameters for each and every CloudStack API requests.
     *
     * @param command API command eg. deployVirtualMachine
     * @param optionalParameters excluding mandatory fields.
     * @return queryValue pair.
     */
    public MultiValueMap<String, String> handleMultiValuedQueryParam(String command, HashMap<String, String> optionalParameters) {
    	MultiValueMap<String, String> queryValueSet = new LinkedMultiValueMap<String, String>();
    	queryValueSet.add("command", command);
    	queryValueSet.add("apiKey", apiKey);
    	LOGGER.debug("Requested Command " + command);
        if (optionalParameters != null) {
            Iterator optionalParam = optionalParameters.entrySet().iterator();
            while (optionalParam.hasNext()) {
                Map.Entry values = (Map.Entry) optionalParam.next();
                queryValueSet.add((String) values.getKey(), (String) values.getValue());
            }
        }
        return queryValueSet;
    }

    /**
     * Whether you access the CloudStack API with HTTP or HTTPS, it must still be signed so that CloudStack can verify
     * the caller has been authenticated and authorized to execute the command.
     *
     * @param queryValuePair request parameters.
     * @return signature for request.
     * @throws java.security.NoSuchAlgorithmException if tried to execute different algorithm except HMAC SHA1
     * @throws java.security.InvalidKeyException if secret or api key is invalid.
     */
    private String generateSignature(MultiValueMap<String, String> queryValuePair)
            throws java.security.NoSuchAlgorithmException, java.security.InvalidKeyException {
    	TreeMap<String, String>	sortedValuePair = new TreeMap<String,String>(queryValuePair.toSingleValueMap());
    	List<NameValuePair> nvpList = new ArrayList<>(sortedValuePair.size());
    	for (Map.Entry<String, String> entry : sortedValuePair.entrySet()) {
    	  nvpList.add(new NameValuePair(entry.getKey(), entry.getValue()));
    	}
		String requestQuery = EncodingUtil.formUrlEncode(nvpList.toArray(new NameValuePair[nvpList.size()]), "UTF-8")
				.replace("+", "%20").replace("%5B", "[").replace("%5D", "]");
    	Mac mac = Mac.getInstance("HmacSHA1");
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getBytes(), "HmacSHA1");
        mac.init(secretKeySpec);
        byte[] digest = mac.doFinal(requestQuery.toLowerCase().getBytes());
        LOGGER.info("API SIGNATURE" +  DatatypeConverter.printBase64Binary(digest));
    	return DatatypeConverter.printBase64Binary(digest);
    }

    /**
     * Whether you access the CloudStack API with HTTP or HTTPS, it must still be signed so that CloudStack can verify
     * the caller has been authenticated and authorized to execute the command.
     *
     * @param queryValuePair request parameters.
     * @return signature for request.
     * @throws java.security.NoSuchAlgorithmException if tried to execute different algorithm except HMAC SHA1
     * @throws java.security.InvalidKeyException if secret or api key is invalid.
     */
    private String generateSignatureForPost(MultiValueMap<String, String> queryValuePair)
            throws java.security.NoSuchAlgorithmException, java.security.InvalidKeyException {
    	TreeMap<String, String>	sortedValuePair = new TreeMap<String,String>(queryValuePair.toSingleValueMap());
    	List<NameValuePair> nvpList = new ArrayList<>(sortedValuePair.size());
    	for (Map.Entry<String, String> entry : sortedValuePair.entrySet()) {
    	  nvpList.add(new NameValuePair(entry.getKey(), entry.getValue()));
    	}
		String requestQuery = EncodingUtil.formUrlEncode(nvpList.toArray(new NameValuePair[nvpList.size()]), "UTF-8")
				.replace("+", "%20").replace("%5B", "[").replace("%5D", "]");
    	byte[] digest = requestQuery.toLowerCase().getBytes();
    	LOGGER.info("API SIGNATURE" +  DatatypeConverter.printBase64Binary(digest));
    	return DatatypeConverter.printBase64Binary(digest);
    }
}
